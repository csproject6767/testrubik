<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CubeZilla Solver</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<style>
:root {
  --bg-main: #020617;
  --bg-panel: #0b1120;
  --bg-glass: rgba(15, 23, 42, 0.92);
  --accent-primary: #6366f1;
  --accent-glow: #8b5cf6;
  --accent-soft: #a5b4fc;
  --text-main: #e5e7eb;
  --text-muted: #9ca3af;
  --border-glow: rgba(99, 102, 241, 0.4);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  width: 100%;
  height: 100vh;
  background:
    radial-gradient(ellipse at top left, rgba(99,102,241,0.18) 0%, transparent 55%),
    radial-gradient(ellipse at bottom right, rgba(139,92,246,0.16) 0%, transparent 55%),
    linear-gradient(135deg, #020617 0%, #020617 100%);
  font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
  color: var(--text-main);
  overflow: hidden;
}

/* Start overlay */
#overlay {
  position: fixed;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 100;
  background: radial-gradient(circle at 10% 10%, rgba(79,70,229,0.35) 0%, transparent 45%),
              radial-gradient(circle at 90% 90%, rgba(147,51,234,0.3) 0%, transparent 45%),
              rgba(2,6,23,0.96);
}

.page {
  text-align: left;
  padding: 40px 44px 32px;
  max-width: 480px;
  width: 90vw;
  background:
    linear-gradient(145deg, rgba(15,23,42,0.96) 0%, rgba(15,23,42,0.92) 100%);
  border-radius: 26px;
  border: 1px solid rgba(148,163,184,0.4);
  box-shadow:
    0 30px 80px rgba(15,23,42,0.9),
    0 0 40px rgba(79,70,229,0.4);
  position: relative;
  overflow: hidden;
}

.page::before {
  content: '';
  position: absolute;
  inset: -1px;
  border-radius: 26px;
  background: radial-gradient(circle at 0% 0%, rgba(129,140,248,0.4) 0%, transparent 45%),
              radial-gradient(circle at 100% 100%, rgba(236,72,153,0.3) 0%, transparent 45%);
  opacity: 0.45;
  mix-blend-mode: screen;
  pointer-events: none;
}

.page h1 {
  font-size: 2.1rem;
  margin-bottom: 12px;
  letter-spacing: -0.03em;
  background: linear-gradient(135deg, #e5e7eb, #a5b4fc);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.page p {
  margin-bottom: 18px;
  color: var(--text-muted);
  line-height: 1.6;
  font-size: 0.95rem;
}

/* Buttons */
.pop-btn, button {
  padding: 12px 26px;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-glow));
  color: white;
  border: none;
  border-radius: 999px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.95rem;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  box-shadow:
    0 18px 40px rgba(59,130,246,0.45),
    0 0 0 1px rgba(129,140,248,0.6);
}

.pop-btn:hover, button:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow:
    0 24px 55px rgba(79,70,229,0.6),
    0 0 0 1px rgba(191,219,254,0.9);
}

/* Layout */
#main-app {
  display: none;
  height: 100vh;
  grid-template-columns: 300px 1fr;
}

/* Sidebar */
#sidebar {
  background: linear-gradient(180deg, #020617 0%, #020617 60%, #020617 100%);
  border-right: 1px solid rgba(15,23,42,1);
  padding: 22px 20px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  box-shadow: 10px 0 40px rgba(0,0,0,0.6);
}

#method-title {
  font-size: 0.9rem;
  color: var(--accent-soft);
  letter-spacing: 0.16em;
  text-transform: uppercase;
  margin-bottom: 8px;
}

#sidebar .pop-btn {
  width: 100%;
  justify-content: center;
}

/* Cube area */
#cube-container {
  position: relative;
  flex: 1;
}

/* Solve info chip */
#solve-info {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 8px 18px;
  background: rgba(15,23,42,0.95);
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.6);
  color: var(--text-muted);
  font-size: 0.8rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  opacity: 0;
  transition: opacity 0.3s ease;
  z-index: 10;
}

/* Camera column */
.camera-column {
  position: absolute;
  top: 50%;
  left: 24px;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.camera-btn {
  width: 46px;
  height: 46px;
  background: radial-gradient(circle at 30% 0%, #111827, #020617);
  color: #e5e7eb;
  border-radius: 14px;
  border: 1px solid rgba(75,85,99,0.9);
  cursor: pointer;
  font-weight: 600;
}

/* Move bar */
.move-bar {
  position: absolute;
  bottom: 34px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  padding: 14px 16px;
  background: rgba(15,23,42,0.98);
  border-radius: 18px;
  border: 1px solid rgba(51,65,85,0.9);
}

.move-btn {
  padding: 8px 10px;
  min-width: 40px;
  background: #0f172a;
  color: #e5e7eb;
  border-radius: 10px;
  border: 1px solid rgba(55,65,81,0.9);
  cursor: pointer;
  font-size: 0.8rem;
  text-transform: uppercase;
}
</style>
</head>
<body>

<div id="overlay">
  <div class="page">
    <h1>CubeZilla Solver</h1>
    <p>A cinematic 3D Rubik’s cube that records every move you make and can rewind the entire scramble on command.</p>
    <p style="margin-bottom: 22px;">
      Learn how a solver “thinks” through CFOP-style phases while you experiment with your own scrambles.
    </p>

    <div style="display:flex; flex-direction:column; gap:12px; margin-bottom:26px;">
      <button class="pop-btn" onclick="startSolver()">
        ▶ Solve a scramble
      </button>

      <button class="pop-btn" style="background:linear-gradient(135deg,#0f172a,#111827); box-shadow:none; border:1px solid rgba(148,163,184,0.5); color:#e5e7eb;"
              onclick="showHowItWorks()">
        ? How does the app work?
      </button>

      <button class="pop-btn" style="background:linear-gradient(135deg,#22c55e,#16a34a); box-shadow:0 18px 40px rgba(34,197,94,0.4);"
              onclick="startSolver()">
        ⚡ Free‑play with the cube
      </button>
    </div>

    <div style="margin-top:10px; padding-top:10px; border-top:1px solid rgba(55,65,81,0.7); display:flex; justify-content:space-between; align-items:center; font-size:0.8rem; color:#9ca3af;">
      <span>Credits: Anirudh · Madhav · Pratik</span>
      <span style="opacity:0.8;">v1.0 · experimental</span>
    </div>
  </div>
</div>

<div id="main-app">
  <div id="sidebar">
    <h2 id="method-title">CONTROLS</h2>
    <button class="pop-btn" onclick="scramble()">Scramble</button>
    <button class="pop-btn" onclick="solveCube()">Solve</button>
    <button class="pop-btn" onclick="resetCube()">Reset Cube</button>
    <button class="pop-btn" onclick="resetView()">Reset View</button>
    <button class="pop-btn" style="background:#374151" onclick="backToMenu()">Back to menu</button>
  </div>
  <div id="cube-container">
    <div id="solve-info"></div>
    <div class="camera-column">
      <button class="camera-btn" onclick="snapAndReorient('front')">F</button>
      <button class="camera-btn" onclick="snapAndReorient('right')">R</button>
      <button class="camera-btn" onclick="snapAndReorient('back')">B</button>
      <button class="camera-btn" onclick="snapAndReorient('left')">L</button>
      <button class="camera-btn" onclick="snapAndReorient('up')">U</button>
      <button class="camera-btn" onclick="snapAndReorient('down')">D</button>
    </div>
    <div class="move-bar">
      <button class="move-btn" onclick="screenMove('R')">R</button>
      <button class="move-btn" onclick="screenMove('R_prime')">R'</button>
      <button class="move-btn" onclick="screenMove('L')">L</button>
      <button class="move-btn" onclick="screenMove('L_prime')">L'</button>
      <button class="move-btn" onclick="screenMove('U')">U</button>
      <button class="move-btn" onclick="screenMove('U_prime')">U'</button>
      <button class="move-btn" onclick="screenMove('F')">F</button>
      <button class="move-btn" onclick="screenMove('F_prime')">F'</button>
    </div>
  </div>
</div>

<script>
let scene, camera, renderer, cubies = [], cubeGroup;
let moveHistory = [];
let isRotating = false, isChangingView = false;
let currentView = { theta: 0, phi: 0.3 };
const zoomDistance = 12;

// --- Solve commentary + helpers ---
const solveMessages = {
  scan: [
    'Scanning cross & F2L pairs',
    'Reading current cube pattern',
    'Estimating piece cycles & orbits',
    'Profiling edge and corner misplacements'
  ],
  eval: [
    'Comparing CFOP vs beginner routes',
    'Checking white cross efficiencies',
    'Preserving existing solved blocks',
    'Scoring possible first-layer options'
  ],
  method: [
    'Found fastest method: CFOP-style route',
    'Using: Optimized F2L + 2-Look OLL',
    'Using: Cross-first CFOP hybrid',
    'Using: Block-building + CFOP mix'
  ],
  execute: [
    'Executing: Cross → F2L → OLL → PLL',
    'Executing: Lock cross, build all F2L pairs',
    'Executing: Orient last layer, then permute',
    'Executing: Preserve solved slots while finishing LL'
  ]
};

function pickRandom(list) { return list[Math.floor(Math.random() * list.length)]; }

function setSolveInfo(text) {
  const el = document.getElementById('solve-info');
  if (!el) return;
  el.textContent = text;
  el.style.opacity = text ? '1' : '0';
}

function showHowItWorks() {
  alert(`HOW THE APP WORKS

1) Scramble
- Press “Scramble” or do your own moves with the move buttons.
- Every move (including scramble) is recorded in order.

2) Play with the cube
- Use the face buttons (F, R, B, L, U, D) to rotate the view.
- Click any move (R, U, F, etc.) as many times as you want.
- The cube turns just like a real 3×3.

3) Solve
- When you press “Solve”, the app:
  • Analyzes your full move history,
  • Shows random CFOP-style technique notes,
  • Then rewinds your exact sequence back to the solved state.

4) Reset
- “Reset Cube” reloads everything back to the original solved cube and main menu style.`
  );
}

function backToMenu() {
  location.reload();
}

function startSolver() {
  document.getElementById('overlay').style.display = 'none';
  document.getElementById('main-app').style.display = 'grid';
  setup3D();
}

function setup3D() {
  const container = document.getElementById('cube-container');
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.7));
  const dl = new THREE.DirectionalLight(0xffffff, 0.8);
  dl.position.set(3, 5, 4);
  scene.add(dl);

  cubeGroup = new THREE.Group();
  scene.add(cubeGroup);

  const colors = [0xff0000, 0xffa500, 0xffffff, 0xffff00, 0x00ff00, 0x0000ff];
  for (let x = -1; x <= 1; x++) {
    for (let y = -1; y <= 1; y++) {
      for (let z = -1; z <= 1; z++) {
        if (x === 0 && y === 0 && z === 0) continue;
        const materials = colors.map(c => new THREE.MeshLambertMaterial({ color: c }));
        const cubie = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.95, 0.95), materials);
        cubie.position.set(x, y, z);
        cubies.push(cubie);
        cubeGroup.add(cubie);
      }
    }
  }

  snapAndReorient('front');
  animate();
}

function snapAndReorient(targetFace) {
  if (isRotating || isChangingView) return;
  const va = {
    front: { t: 0, p: 0.3 },
    right: { t: -Math.PI/2, p: 0.3 },
    back: { t: Math.PI, p: 0.3 },
    left: { t: Math.PI/2, p: 0.3 },
    up: { t: 0, p: -Math.PI/2 + 0.2 },
    down: { t: 0, p: Math.PI/2 - 0.2 }
  };
  const target = va[targetFace];
  isChangingView = true;
  gsap.to(currentView, {
    theta: target.t, phi: target.p, duration: 0.6,
    onUpdate: () => {
      camera.position.set(
        zoomDistance * Math.cos(currentView.phi) * Math.sin(currentView.theta),
        zoomDistance * Math.sin(currentView.phi),
        zoomDistance * Math.cos(currentView.phi) * Math.cos(currentView.theta)
      );
      camera.lookAt(0, 0, 0);
    },
    onComplete: () => { isChangingView = false; }
  });
}

function screenMove(move) {
  let prime = move.endsWith('_prime');
  let cleanMove = move.replace('_prime', '');
  let screenDir;
  switch (cleanMove) {
    case 'R': screenDir = 'right'; break;
    case 'L': screenDir = 'left'; break;
    case 'U': screenDir = 'up'; break;
    case 'D': screenDir = 'down'; break;
    case 'F': screenDir = 'front'; break;
    case 'B': screenDir = 'back'; break;
  }

  let worldDir = new THREE.Vector3();
  if (screenDir === 'right') worldDir.set(1, 0, 0);
  if (screenDir === 'left') worldDir.set(-1, 0, 0);
  if (screenDir === 'up') worldDir.set(0, 1, 0);
  if (screenDir === 'down') worldDir.set(0, -1, 0);
  if (screenDir === 'front') worldDir.set(0, 0, 1);
  if (screenDir === 'back') worldDir.set(0, 0, -1);

  const inv = cubeGroup.quaternion.clone().invert();
  worldDir.applyQuaternion(inv);

  let axisName, layerSign;
  const ax = Math.abs(worldDir.x), ay = Math.abs(worldDir.y), az = Math.abs(worldDir.z);
  if (ax > ay && ax > az) { axisName = 'x'; layerSign = worldDir.x > 0 ? 1 : -1; }
  else if (ay > ax && ay > az) { axisName = 'y'; layerSign = worldDir.y > 0 ? 1 : -1; }
  else { axisName = 'z'; layerSign = worldDir.z > 0 ? 1 : -1; }

  moveHistory.push(move);
  handleMove(axisName, layerSign, prime);
}

function handleMove(axis, layerSign, prime) {
  if (isRotating) return;
  isRotating = true;
  const pivot = new THREE.Group();
  cubeGroup.add(pivot);
  const moving = [];
  cubies.forEach(c => {
    if (Math.abs(c.position[axis] - layerSign) < 0.1) {
      pivot.attach(c);
      moving.push(c);
    }
  });
  const angle = (prime ? 1 : -1) * Math.PI / 2;
  gsap.to(pivot.rotation, {
    [axis]: angle, duration: 0.25,
    onComplete: () => {
      moving.forEach(c => {
        cubeGroup.attach(c);
        c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
      });
      scene.remove(pivot);
      isRotating = false;
    }
  });
}

function scramble() {
  let count = 0;
  const moves = ['R','R_prime','L','L_prime','U','U_prime','F','F_prime'];
  const interval = setInterval(() => {
    if (isRotating || isChangingView) return;
    if (count >= 15) { clearInterval(interval); return; }
    screenMove(moves[Math.floor(Math.random() * moves.length)]);
    count++;
  }, 260);
}

function solveCube() {
  if (moveHistory.length === 0) return;
  const titleEl = document.getElementById('method-title');
  const originalTitle = titleEl.innerText;
  const reverseMoves = moveHistory.slice().reverse().map(m => m.endsWith('_prime') ? m.replace('_prime','') : m + '_prime');

  titleEl.innerText = 'Analyzing scramble...';
  setSolveInfo(pickRandom(solveMessages.scan));

  setTimeout(() => {
    titleEl.innerText = 'Evaluating strategies...';
    setSolveInfo(pickRandom(solveMessages.eval));
    setTimeout(() => {
      titleEl.innerText = 'Found fastest method';
      setSolveInfo(pickRandom(solveMessages.method));
      setTimeout(() => {
        let idx = 0;
        const total = reverseMoves.length;
        setSolveInfo(pickRandom(solveMessages.execute));
        const interval = setInterval(() => {
          if (isRotating || isChangingView) return;
          if (idx >= total) {
            clearInterval(interval);
            moveHistory = [];
            titleEl.innerText = 'Solved!';
            setSolveInfo('Ready for another scramble');
            setTimeout(() => { titleEl.innerText = originalTitle; setSolveInfo(''); }, 1800);
            return;
          }
          titleEl.innerText = `Solving (${total - idx}/${total})...`;
          screenMove(reverseMoves[idx]);
          idx++;
        }, 320);
      }, 900);
    }, 1100);
  }, 1100);
}

function resetCube() { location.reload(); }
function resetView() { snapAndReorient('front'); }

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script>
</body>
</html>
