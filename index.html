<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CubeZilla - Formula Roadmap</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cubejs@1.3.2/lib/cube.min.js"></script>
<style>
:root {
  --bg-main: #020617;
  --bg-panel: #0b1120;
  --accent-primary: #6366f1;
  --accent-glow: #8b5cf6;
  --text-main: #e5e7eb;
  --text-muted: #9ca3af;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  width: 100%; height: 100vh; background: var(--bg-main);
  font-family: -apple-system, system-ui, sans-serif; color: var(--text-main); overflow: hidden;
}

/* UI Overlay & Pages */
#overlay {
  position: fixed; inset: 0; display: flex; justify-content: center; align-items: center;
  z-index: 100; background: rgba(2,6,23,0.95);
}
.page {
  display: none; text-align: left; padding: 40px; max-width: 500px; width: 90vw;
  background: #0f172a; border-radius: 26px; border: 1px solid rgba(148,163,184,0.3);
  box-shadow: 0 30px 80px rgba(0,0,0,0.8);
}
.page.active { display: block; }

/* Buttons & Elements */
.pop-btn {
  width: 100%; padding: 14px; margin-top: 12px; border-radius: 999px; border: none;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-glow));
  color: white; font-weight: 600; cursor: pointer; text-transform: uppercase;
}
.milestone {
  display: flex; gap: 15px; margin-bottom: 20px; padding: 15px;
  background: rgba(255,255,255,0.03); border-radius: 15px; border-left: 4px solid var(--accent-primary);
}

/* App Layout */
#main-app { display: none; height: 100vh; grid-template-columns: 300px 1fr; }
#sidebar { background: #020617; padding: 20px; border-right: 1px solid #1e293b; }
#cube-container { position: relative; flex: 1; background: radial-gradient(circle, #1e293b 0%, #020617 100%); }
#solve-info {
  position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
  padding: 8px 18px; background: rgba(15,23,42,0.9); border-radius: 999px; opacity: 0;
}
</style>
</head>
<body>

<div id="overlay">
  <div id="p1" class="page active">
    <h1>CubeZilla</h1>
    <p>The ultimate cinematic 3D solver and learning roadmap.</p>
    <button class="pop-btn" onclick="goPage('p-interactive-learn')">Get Started</button>
  </div>

  <div id="p-interactive-learn" class="page">
    <h1>Choose Your Mode</h1>
    <p>Jump straight into the solver or follow our guided learning path.</p>
    <button class="pop-btn" onclick="startApp()">Interactive Solver</button>
    <button class="pop-btn" style="background:#334155" onclick="goPage('p-notation-check')">Learning Path</button>
    <button class="pop-btn" style="background:transparent; border:1px solid #334155" onclick="goPage('p1')">Back</button>
  </div>

  <div id="p-notation-check" class="page">
    <h1>Cube Notations</h1>
    <p>Do you already know how to read moves like R, U', or F2?</p>
    <button class="pop-btn" onclick="goPage('p-level-select')">Yes, I know them</button>
    <button class="pop-btn" style="background:#334155" onclick="goPage('p-notation-learn')">No, teach me</button>
  </div>

  <div id="p-notation-learn" class="page">
    <h1>Notation Basics</h1>
    <p><b>R:</b> Right Side Up | <b>L:</b> Left Side Down<br><b>U:</b> Top Clockwise | <b>D:</b> Bottom Clockwise</p>
    <p><i>Note: An apostrophe (') means turn Counter-Clockwise.</i></p>
    <button class="pop-btn" onclick="goPage('p-level-select')">I've Got It</button>
  </div>

  <div id="p-level-select" class="page">
    <h1>Select Method</h1>
    <p>Choose the system you want to master.</p>
    <button class="pop-btn" onclick="goPage('p-formula-roadmap')">Formula Roadmap</button>
    <button class="pop-btn" style="background:#334155" onclick="alert('Beginner Path selected - Coming Soon')">Beginner Path</button>
    <button class="pop-btn" style="background:transparent" onclick="goPage('p-notation-check')">Back</button>
  </div>

  <div id="p-formula-roadmap" class="page">
    <h1>Formula Roadmap</h1>
    <p>Unlock milestones step by step.</p>
    <div class="milestone">
      <div>
        <h3>Layer-by-Layer Beginner</h3>
        <p>Start with white cross and build up.</p>
        <button class="pop-btn" style="padding:8px" onclick="alert('Beginner Roadmap loading...')">View</button>
      </div>
    </div>
    <div class="milestone">
      <div>
        <h3>CFOP Speedcubing</h3>
        <p>Advanced system for sub-20 second solves.</p>
        <button class="pop-btn" style="padding:8px" onclick="goPage('p-cfop-track')">View</button>
      </div>
    </div>
    <button class="pop-btn" style="background:transparent" onclick="goPage('p-level-select')">â—€ Back</button>
  </div>

  <div id="p-cfop-track" class="page">
    <h1>CFOP Track</h1>
    <p>This is where your custom CFOP content will live.</p>
    <button class="pop-btn" onclick="goPage('p-formula-roadmap')">Back to Roadmap</button>
  </div>
</div>

<div id="main-app">
  <div id="sidebar">
    <h2 id="method-title">Solver</h2>
    <button class="pop-btn" onclick="scramble()">Scramble</button>
    <button class="pop-btn" onclick="solveCube()">Solve</button>
    <button class="pop-btn" style="background:#334155" onclick="location.reload()">Reset</button>
    <button class="pop-btn" style="background:#334155" onclick="goPage('p1')">Exit to Menu</button>
  </div>
  <div id="cube-container">
    <div id="solve-info"></div>
  </div>
</div>

<script>
let scene, camera, renderer, cubeGroup, cubies = [];
let isRotating = false, isAutoSolving = false;
let cubeOrientation = new THREE.Quaternion();

// Page Navigation
function goPage(id) {
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  document.getElementById('overlay').style.display = 'flex';
  document.getElementById('main-app').style.display = 'none';
}

function startApp() {
  document.getElementById('overlay').style.display = 'none';
  document.getElementById('main-app').style.display = 'grid';
  if (!scene) setup3D();
}

function setup3D() {
  const container = document.getElementById('cube-container');
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(35, container.clientWidth/container.clientHeight, 0.1, 1000);
  camera.position.set(6, 6, 12);
  camera.lookAt(0,0,0);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  const ambient = new THREE.AmbientLight(0xffffff, 0.8);
  scene.add(ambient);

  cubeGroup = new THREE.Group();
  scene.add(cubeGroup);

  const colors = [0xff0000, 0xffa500, 0xffffff, 0xffff00, 0x00ff00, 0x0000ff];
  for(let x=-1; x<=1; x++) {
    for(let y=-1; y<=1; y++) {
      for(let z=-1; z<=1; z++) {
        if(x===0 && y===0 && z===0) continue;
        const mats = colors.map(c => new THREE.MeshLambertMaterial({color: c}));
        const cubie = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.95, 0.95), mats);
        cubie.position.set(x, y, z);
        cubies.push(cubie);
        cubeGroup.add(cubie);
      }
    }
  }
  animate();
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

// FIX: GLITCHED MOVEMENT LOGIC
function getCubeAxisForScreenDirection(screenDirName) {
  let worldDir = new THREE.Vector3();
  switch (screenDirName) {
    case 'right': worldDir.set(1, 0, 0); break;
    case 'left': worldDir.set(-1, 0, 0); break;
    case 'up': worldDir.set(0, 1, 0); break;
    case 'down': worldDir.set(0, -1, 0); break;
    case 'front': worldDir.set(0, 0, 1); break;
    case 'back': worldDir.set(0, 0, -1); break;
    default: return null;
  }

  // Apply inverse cube rotation to get local cube axis
  const inv = cubeGroup.quaternion.clone().invert();
  worldDir.applyQuaternion(inv);

  const ax = Math.abs(worldDir.x), ay = Math.abs(worldDir.y), az = Math.abs(worldDir.z);
  let axisName, layerSign;

  if (ax > ay && ax > az) {
    axisName = 'x'; layerSign = worldDir.x > 0 ? 1 : -1;
  } else if (ay > ax && ay > az) {
    axisName = 'y'; layerSign = worldDir.y > 0 ? 1 : -1;
  } else {
    axisName = 'z'; layerSign = worldDir.z > 0 ? 1 : -1;
  }
  return { axisName, layerSign };
}

function handleMove(axis, layerSign, prime) {
  if (isRotating) return;
  isRotating = true;
  const pivot = new THREE.Group();
  scene.add(pivot);
  
  const movingCubies = [];
  cubies.forEach(cubie => {
    const localPos = cubie.position.clone();
    if (Math.abs(localPos[axis] - layerSign) < 0.1) {
      pivot.attach(cubie);
      movingCubies.push(cubie);
    }
  });

  const angle = (prime ? 1 : -1) * Math.PI / 2;
  gsap.to(pivot.rotation, {
    [axis]: angle, duration: 0.25, ease: "power2.inOut",
    onComplete: () => {
      movingCubies.forEach(cubie => {
        cubeGroup.attach(cubie);
        // Snap to nearest integer to avoid drift
        cubie.position.set(
          Math.round(cubie.position.x),
          Math.round(cubie.position.y),
          Math.round(cubie.position.z)
        );
      });
      scene.remove(pivot);
      isRotating = false;
    }
  });
}

// Simple move wrappers (Simulating R, L, etc. logic)
function performMove(type, isPrime) {
  const mapping = {
    'R': 'right', 'L': 'left', 'U': 'up', 'D': 'down', 'F': 'front', 'B': 'back'
  };
  const { axisName, layerSign } = getCubeAxisForScreenDirection(mapping[type]);
  handleMove(axisName, layerSign, isPrime);
}

// Global Key Listeners for Testing
window.addEventListener('keydown', (e) => {
  if (isRotating) return;
  const key = e.key.toUpperCase();
  const isPrime = e.shiftKey;
  if (['R','L','U','D','F','B'].includes(key)) performMove(key, isPrime);
});

function scramble() {
  let count = 0;
  const moves = ['R','L','U','D','F','B'];
  const interval = setInterval(() => {
    performMove(moves[Math.floor(Math.random()*6)], Math.random() > 0.5);
    if (++count > 15) clearInterval(interval);
  }, 300);
}
</script>
</body>
</html>
